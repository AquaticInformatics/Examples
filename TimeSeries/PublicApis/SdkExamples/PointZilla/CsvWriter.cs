using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Aquarius.TimeSeries.Client.ServiceModels.Acquisition;
using NodaTime;
using NodaTime.Text;
using ServiceStack.Logging;

namespace PointZilla
{
    public class CsvWriter
    {
        private static readonly ILog Log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        private Context Context { get; }

        public CsvWriter(Context context)
        {
            Context = context;
        }

        public void WritePoints(List<TimeSeriesPoint> points)
        {
            var timeSeriesIdentifier = CreateTimeSeriesIdentifier();

            var csvPath = Directory.Exists(Context.SaveCsvPath)
                ? Path.Combine(Context.SaveCsvPath, SanitizeFilename($"{timeSeriesIdentifier.Identifier}.{CreatePeriod(Context.SourceQueryFrom, Context.SourceQueryTo)}.csv"))
                : Context.SaveCsvPath;

            Log.Info($"Saving {points.Count} extracted points to '{csvPath}' ...");

            var dir = Path.GetDirectoryName(csvPath);

            if (!string.IsNullOrEmpty(dir))
            {
                Directory.CreateDirectory(dir);
            }

            using (var writer = new StreamWriter(csvPath))
            {
                var offsetPattern = OffsetPattern.CreateWithInvariantCulture("m");
                var utcOffsetText = $"UTC{offsetPattern.Format(Context.UtcOffset ?? Offset.Zero)}";
                var period = CreatePeriod(Context.SourceQueryFrom ?? Instant.MinValue, Context.SourceQueryTo ?? Instant.MaxValue);

                writer.WriteLine($"# {Path.GetFileName(csvPath)} generated by {Context.ExecutingFileVersion}");
                writer.WriteLine($"#");
                writer.WriteLine($"# Time series identifier: {timeSeriesIdentifier.Identifier}");
                writer.WriteLine($"# Location: {timeSeriesIdentifier.LocationIdentifier}");
                writer.WriteLine($"# UTC offset: ({utcOffsetText})");
                writer.WriteLine($"# Value units: {Context.Unit}");
                writer.WriteLine($"# Value parameter: {timeSeriesIdentifier.Parameter}");
                writer.WriteLine($"# Interpolation type: {Context.InterpolationType}");
                writer.WriteLine($"# Time series type: {Context.TimeSeriesType}");
                writer.WriteLine($"#");
                writer.WriteLine($"# Export options: Corrected signal from {period.StartText} to {period.EndText}");
                writer.WriteLine($"#");
                writer.WriteLine($"# CSV data starts at line 15.");
                writer.WriteLine($"#");
                writer.WriteLine($"ISO 8601 UTC, Value, Grade, Qualifiers");

                foreach (var point in points)
                {
                    var time = point.Time ?? Instant.MinValue;

                    writer.WriteLine($"{InstantPattern.ExtendedIsoPattern.Format(time)}, {point.Value:G12}, {point.GradeCode}, {FormatQualifiers(point.Qualifiers)}");
                }
            }
        }

        public static void SetPointZillaCsvFormat(Context context)
        {
            // Match PointZilla Export format below

            // # CSV data starts at line 15.
            // # 
            // ISO 8601 UTC, Value, Grade, Qualifiers
            // 2015-12-04T00:01:00Z, 3.523200823975, 500, 
            // 2015-12-04T00:02:00Z, 3.525279357147, 500, 

            context.CsvDateTimeField = 1;
            context.CsvDateTimeFormat = null;
            context.CsvDateOnlyField = 0;
            context.CsvTimeOnlyField = 0;
            context.CsvValueField = 2;
            context.CsvGradeField = 3;
            context.CsvQualifiersField = 4;
            context.CsvComment = "#";
            context.CsvSkipRows = 0;
            context.CsvIgnoreInvalidRows = true;
            context.CsvRealign = false;
        }

        private TimeSeriesIdentifier CreateTimeSeriesIdentifier()
        {
            if (Context.SourceTimeSeries != null)
                return Context.SourceTimeSeries;

            if (!string.IsNullOrEmpty(Context.TimeSeries))
                return TimeSeriesIdentifierParser.ParseExtendedIdentifier(Context.TimeSeries);

            string parameter;
            var label = "Points";
            var locationIdentifier = "PointZilla";

            if (DeleteCommands.Contains(Context.Command))
                parameter ="Deleted";

            else if (Context.ManualPoints.Any())
                parameter = "ManuallyEntered";
            else if (Context.CsvFiles.Any())
                parameter = "OtherCsvFile";
            else
                parameter = Context.WaveformType.ToString();

            return new TimeSeriesIdentifier
            {
                Parameter = parameter,
                Label = label,
                LocationIdentifier = locationIdentifier,
                Identifier = $"{parameter}.{label}@{locationIdentifier}"
            };
        }

        private static readonly HashSet<CommandType> DeleteCommands = new HashSet<CommandType>
        {
            CommandType.DeleteAllPoints,
            CommandType.DeleteTimeRange,
        };

        private static string CreatePeriod(Instant? startTime, Instant? endTime)
        {
            var start = startTime ?? Instant.MinValue;
            var end = endTime ?? Instant.MaxValue;

            if (start == Instant.MinValue && end == Instant.MaxValue)
                return "EntireRecord";

            var period = CreatePeriod(start, end);

            return $"{period.StartText}.{period.EndText}";
        }

        private static (string StartText, string EndText) CreatePeriod(Instant start, Instant end)
        {
            return (
                start == Instant.MinValue ? "StartOfRecord" : InstantPattern.ExtendedIsoPattern.Format(start),
                end == Instant.MaxValue ? "EndOfRecord" : InstantPattern.ExtendedIsoPattern.Format(end)
            );

        }

        private static string FormatQualifiers(List<string> qualifiers)
        {
            if (qualifiers == null || !qualifiers.Any())
                return string.Empty;

            if (qualifiers.Count == 1)
                return qualifiers.First();

            return $"\"{string.Join(",", qualifiers)}\"";
        }

        private static string SanitizeFilename(string s)
        {
            return Path.GetInvalidFileNameChars().Aggregate(s, (current, ch) => current.Replace(ch, '_'));
        }
    }
}
